---
layout: post
title: "Crypto"
date: 2017-04-19 23:00:00 +0900
toc: true
---

# Index

* TOC
{:toc}

# 古典暗号

## シーザー暗号

## 単一換字暗号

## Enigma

タイプライターと歯車と電池を組み合わせたような機械。

送信者と受信者はそれぞれエニグマを持つ。
動的に変化するあみだくじのようなふるまい

```
鍵表: 送信者、受信者が使う日替わり鍵が書いてある
日替わり鍵: 鍵を暗号化するための鍵（鍵暗号鍵: KEK）, ハイブリッド暗号でも使う
```

### 暗号化

```
1. エニグマの設定
2. 通信鍵の暗号化
3. エニグマの再設定
4. メッセージの暗号化
5. 結合
```

[1] エニグマの設定

Sender: 日替わり鍵をエニグマに設定

[2] 通信鍵の暗号化

アルファベット3文字(通信鍵)を任意に決めて暗号化。エニグマで通信鍵を2回続けて入力。１入力ごとにローターが回りランプが点灯する。点灯したものが暗号文

2回続けて入力するのは、受信者側が正しく送られてきたかを検証できるから

[3] 再設定

アルファベット３文字は３枚のローターの取り付け角度を表す。文字に対応した角度を設定できる。

[4] メッセージの暗号化

エニグマに平文を１文字ずつ入力してその出力（点灯するランプ）

[5] 結合

暗号化された通信鍵＋暗号化されたメッセージ　の一文を送信

### 復号化

```
1. 分解
2. エニグマの設定
3. 通信鍵の復号化
4. エニグマの再設定
5. メッセージの復号化
```

[1] 分解

通信鍵とメッセージを分解

[2] エニグマの設定

日替わり鍵をエニグマに設定

[3] 通信鍵の復号化

暗号化された通信鍵を設定したエニグマに打ち込むと復号できる

[4] エニグマの再設定

復号した通信鍵に従って再設定

[5] メッセージの復号化

再設定したエニグマにメッセージを１文字ずつ打ち込めばおk

### 弱点

* 暗号化時にローター１しか回転しない
* 通信鍵を２回繰り返したのを暗号化する
* 鍵表を配布しないといけなかった

## Vigenere Cipher

多表式換字式暗号

### 暗号化・復号化

Vigenere方陣を使う。

```
上段 → 平文
左段 → 暗号鍵
他　 → 暗号文
```

< 数学で見る >

```
Pi: 平文のi文字目
Ki: 鍵のi文字目
Ci: 暗号文のi文字目
```

```
Ci = (Pi + Ki) mod 26
Pi = (Ci - Ki) mod 26
```

### 解読

カシスキー・テスト

by wikipedia

```
1. まず、同じ文字の（反復している文字の）羅列を探る（ただし頻度分析ではないので、cが多いなどは関係ない）。また、文字列は長いほうが確実である（1文字から3文字程度ならいくらでも現れる可能性があるので）。
2. 次にその羅列の間隔を数える（たとえば、cdfkkuihycdfkgの場合、cdfkが反復して現れる。この間隔は9である）。
3. 以下、同じように探していくと発見された文字間隔がたとえば、9、63、180、であったとき、この三つの数に共通する因数は3と9であるため、鍵の文字数は3か9であると仮定できる。
4. すると、この暗号の最大の関門、鍵の文字数が分かってしまったのだ。すると、頻度分析が使える（ここでは、文字数を3としたが、それで答えが出なければ9でやってみる）。つまり、間隔が3の文字同士は、同じ行のヴィジュネル方陣が使われているということだ。
5. 頻度分析にかけるが、大事なのは1つだけの行を使った場合、単なるシーザー暗号になるということだ。つまり、暗号文の3の間隔同士の文字の頻度をグラフで見ると、平文で行った頻度分析と似ているようで似ていない形になる。しかし、シーザー暗号を使っているということは、文字いくらかずらせば、平文の頻度解析を行ったものとほぼ同じになる。
6. 以上を使うとほぼ、ヴィジュネル暗号を解ける。
```

# 対称暗号(共通鍵暗号)

```
DES(Data Encryption Standard)
TDES(Triple DES)
AES(Advanced Encryption Standard)
```

## DES

現在はブルートフォースアタックで容易に解読可能

### 暗号化・復号化

ブロック暗号一種

64bitの平文を64bitの暗号文に暗号化する

鍵は56bit(64bitだが7bitごとにエラー検出の情報が1bit入る(パリティチェック))

```
ブロック: 64bitの平文
ブロック暗号: ブロック単位で処理する
```

64bitずつの暗号化を繰り返す。 → モード

### 構造 (ファイステルネットワーク)

暗号化の１ステップ(ラウンド)を何度も繰り返す。

DESは16ラウンドのファイステルネットワーク

ファイステルネットワークでは、暗号鍵をサブ鍵と呼ぶ。（ラウンドごとに使うから？）

```
1. 64bitの入力を32bitずつ左右に分ける
2. 右をそのまま右出力におくる
3. 右をラウンド関数に送る
4. ラウンド関数は右とサブ鍵でビット列を計算
5. ビット列と左をXORしたものを左出力に送る
6. 最終ラウンドなら終わる
7. 右出力と左出力を入れ替える
8. サブ鍵を変更
9. 2に戻る
```

ラウンド数が何回でもよい

ラウンド関数にどんな関数をつかっても復号ができる（出力から入力を逆算できなくてよい）

暗号化と復号化が同じ構造である

### 解読法

* 差分解読法
  * 平文の一部を変更すると暗号文がどう変わるか を調べる
* 線形解読法
  * 平文と暗号文のビットをいくつかXORして0になる確率を調べる
  * 暗号文が完全にランダムなら確率は1/2になるはず。1/2からのずれが大きいビット箇所を調べて鍵の情報を得る。


## トリプルDES

DESを3段重ねにしたもの

### 暗号化

平文を３回DESにかけるのではなく、
```
1. 暗号化
2. 復号化
3. 暗号化
```
になっている。DESとして使えるようにするため（すべて同じ鍵を使うと単独のDESになる）


```
DES-EDE2: 鍵１と鍵３に同じ鍵、鍵２に違う鍵を使う
DES-EDE3: すべての鍵を違う値を使う
```

### 復号化

```
1. 復号化
2. 暗号化
3. 復号化
```
を行う。

現状, まだつかわれてるところはあるけど、処理速度が遅い。

## AES

```
MARS
RC6
Rijndael
Serpent
Twofish
```
から `Rijndael` 選ばれた。

```
ブロック長: 126bits
鍵ビット長: 128, 192, 256bits]
```

### SPN構造

```
1. 1byteごとに1byteの値(1-255のどれか)をインデックスとし、256個の値をもっている換字表(SBox)から１個の値を得る。(SubBytes, 単一換字暗号の256文字版)
2. 4byte単位にまとまった行を左に規則的にシフトして混ぜる処理。(ShiftRows)
3. 4byteの値をビット演算を用いて別の4byte値に変換する。(MixColumns)
4. MixColumnsの出力とラウンド鍵とのXORをとる(AddRoundKey)
```

このラウンドを10-14回繰り返す。

### 暗号化

SubBytes -> ShiftRows -> MixColumns -> AddRoundKey

### 復号化

AddRoundKey -> InvMixColumns -> InvShiftRows -> InvSubBytes


# 公開鍵暗号

## RSA (Rivest-Shamir-Adleman) Initial

* 公開鍵暗号アルゴリズム
* 公開鍵暗号とデジタル署名に使える

### 暗号化

```
暗号文 = 平文^E mod N
```

平文をE乗して mod Nをとる

公開鍵 = {E, N}

### 復号化

```
平文 = 暗号文^D mod N
```

暗号文をD乗して mod Nをとる

秘密鍵 = {D, N}

### 鍵の生成
```
1. N を求める
2. L を求める
3. E を求める
4. D を求める
```

[1] N を求める

* 2つの素数 p, qを用意。(それぞれ1024bits以上が望ましい)
  * (p, q)が小さいと解読が容易になり、大きすぎると処理時間が長くなる。
  * 擬似乱数生成器で素数を生成(フェルマーテストやミラー・ラビンテストなどで素数判定)

* ` N = p × q` (2014bits以上)

[2] L を求める

* 鍵生成時にのみ使う
* `p-1`と`q-1`の最小公倍数(lcm: lease common multiple)
* `L = lcm(p-1, q-1)`

[3] E を求める

* `1 < E < L`
* EとLの最大公約数(gcd: greatest common divisor)が必ず １
* 以下を満たす
  ```
  1 < E < L
  gcd(E, L) = 1
  ```
* `1 < E < L `の範囲から乱数を生成してそれが`gcd(E, L) = `を満たすかを調べる(ユークリッドの互除法)

[4] D を求める

* 以下を満たす
  ```
  1 < D < L
  E × D mod L = 1
  ```

### RSA への攻撃

* ブルートフォースアタック
  * 2048ビット以上の攻撃が必要なので現実的ではない
* E, N からDを求める
  * RSAは素数p, qを知られてはいけない。秘密鍵が知られることに等しい
* N を素因数分解
  * 現在は無理だが、大きな数の素因数分解を高速でできるような方法があればRSAは突破される
* MITM攻撃(Man-In-The-Middle)
  * 対策: 証明書
* 選択暗号文攻撃
  * 復号オラクル(データを送ると復号化してくれるサービス)を使う。ことで平文の情報の一部が漏れることがある。
  * 対策: 証明書 -> RSA-OAEP(Optimal Asymmetric Encryption Padding)

# 一方向ハッシュ関数

* 入力 → メッセージ、プレ・イメージ
* 出力 → ハッシュ値、メッセージダイジェスト、フィンガープリント
* 正真性（本物か改竄されていないか）を保証する
* 任意長から固定長のハッシュ値を算出する
* 高速
* メッセージが1バイトでも変わればハッシュ値は異なる値になる
* 一方向性（逆算できない（ハッシュ値　－＞　平文））
* 衝突耐性（２つの異なるメッセージが同じハッシュ値にならない）
* なりすましは防げない


## SHA-3

```
BLAKE
Grostl
jH
Keccak
Skein
```

から`Keccak`が選定された

## Keccak

* 入力サイズに制限がない
* スポンジ構造
  * メッセージにパディング（サイズを合わせる）をする
  * 吸収フェーズ
    * メッセージをrビットのブロックに分割
    * rビットとブロック１のXORをとり、関数fへ渡す
    * fの出力rビットとブロック２のXORをとり、fへ渡す
    * ブロックが尽きるまで行い次のフェーズへ
  * 搾出フェーズ
    * fの出力のうちrビットを出力ブロック１とする。出力全体はfへ再度渡す
    * 必要なビット数が得られるまで行う
  * デュプレクス構造も提案されてる
  *

### 攻撃

* プルートフォースアタック
* 誕生日攻撃



## 一覧

by wikipedia

|                アルゴリズム                |  出力長（ビット）   | 内部状態長 | ブロック長 | メッセージ長（を表すビット数） | ワード長 |     衝突攻撃 (complexity)      | 原像攻撃 (complexity)  |   |
|:------------------------------------------:|:-------------------:|:----------:|:----------:|:------------------------------:|:--------:|:------------------------------:|:----------------------:|---|
|              HAVAL（英語版）               | 256/224/192/160/128 |    256     |    1024    |               64               |    32    |              Yes               |                        |   |
|                    MD2                     |         128         |    384     |    128     |               No               |    8     |             Almost             |                        |   |
|                    MD4                     |         128         |    128     |    512     |               64               |    32    |    Yes            (2^1)[12]    | With flaws (2^102)[13] |   |
|                    MD5                     |         128         |    128     |    512     |               64               |    32    |   Yes                  (2^5)   |           No           |   |
|              Panama（英語版）              |         256         |    8736    |    256     |               No               |    32    |              Yes               |                        |   |
|            RadioGatún（英語版）            |  Arbitrarily long   |  58 words  |  3 words   |               No               |   1-64   |              Yes               |                        |   |
|                   RIPEMD                   |         128         |    128     |    512     |               64               |    32    |              Yes               |                        |   |
|               RIPEMD-128/256               |       128/256       |  128/256   |    512     |               64               |    32    |               No               |                        |   |
|               RIPEMD-160/320               |       160/320       |  160/320   |    512     |               64               |    32    |               No               |                        |   |
|                   SHA-0                    |         160         |    160     |    512     |               64               |    32    |              Yes               |         (2^39)         |   |
|                   SHA-1                    |         160         |    160     |    512     |               64               |    32    | With flaws           (2^52)[7] |           No           |   |
|              SHA-224, SHA-256              |       256/224       |    256     |    512     |               64               |    32    |               No               |           No           |   |
| SHA-384, SHA-512, SHA-512/224, SHA-512/256 |   384/512/224/256   |    512     |    1024    |              128               |    64    |               No               |           No           |   |
|                  SHA3-224                  |         224         |    1600    |    1152    |               -                |    64    |               No               |           No           |   |
|                  SHA3-256                  |         256         |    1600    |    1088    |               -                |    64    |               No               |           No           |   |
|                  SHA3-384                  |         384         |    1600    |    832     |               -                |    64    |               No               |           No           |   |
|                  SHA3-512                  |         512         |    1600    |    576     |               -                |    64    |               No               |           No           |   |
|       Tiger(2)-192/160/128（英語版）       |     192/160/128     |    192     |    512     |               64               |    64    |               No               |                        |   |
|                 Whirlpool                  |         512         |    512     |    512     |              256               |    8     |               No               |                        |   |
|               MINMAX	256/512                |         512         |    512     |    256     |               8                |    No    |                                |                        |   |

# モード

ブロック暗号を繰り返す方法

ex) TDESをCBCモードで使う。=> 3DES_EDE_CBC <br>
    AESをCBCモードで使う。 => AES_256_CBC


```
1. ECB (Electronic CodeBook mode)
2. CBC (Cipher Block Chaining mode)
3. CFB (Cipher FeedBack mode)
4. OFB (Output FeedBack mode)
5. CTR (CounTeR mode)
```

## ECB

平文ブロックを暗号化したののがそのまま暗号文ブロックになる。

シンプルで機密性は低い

## CBC

1つ前の暗号文ブロックと平文ブロックのXORをとってから暗号化する

１つ目のブロックは、１つ前のブロックの代わりにランダムなビット列をつかう（初期化ベクトル）

SSL/TLS で使われてる

### パディングオラクル攻撃
ブロック暗号のパディング(平文の長さをブロックサイズの整数倍になるように調整する)内容を変化させて暗号文を何度も送信して返ってきたエラーから情報を得る。

SSL3.0に対するPOODLE攻撃で問題になった

正しく認証すれば防げる

## CFB

１つ前の暗号文ブロックを暗号化したもの(鍵ストリーム)と、平文ブロックをXORする

平文ブロックと暗号文ブロックの間に暗号化はされない

ブロック暗号を使って、ストリーム暗号を作っているともいえる。

初期化ベクトルは、ランダムなビット列

復号時は、鍵ストリームを生成するために暗号化ブロックを暗号化する

### 再生攻撃

同じ鍵を使っていた場合、ブロックをすり替えられる。

## OFB

平文ブロックと暗号アルゴリズムの出力をXORして暗号文ブロックを作る

暗号アルゴリズムの出力は、
1. 暗号化(初期化ベクトル)
2. 暗号化(1)
3. 暗号化(2)

をくりかえす

初期化ベクトルはランダムなビット列

## CTR

１ずつ増加していくカウンタを暗号化して、鍵ストリームを作り出すストリーム暗号

カウンタを暗号化したものと、平文ブロックをXOR

### カウンタ

初期値は暗号化のたびに異なる値（ノンス）を使用。
ブロック長が１６ビットなら、前半８ビットをノンス、後半がブロック番号とし、カウントアップしていく

暗号化と復号化は同じ構造

任意の順番で暗号化、復号化できる

## GCM mode (Galois/Conter mode)

CTRに認証機能を追加したもの
