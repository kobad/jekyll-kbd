---
layout: post
title: "Operating System"
date: 2017-04-19 23:00:00 +0900
toc: true
---

# Index

* TOC
{:toc}

## プロセッサ(CPU)
命令をメモリからフェッチ・デコード・実行を繰り返す。

## メモリ階層

|メモリ|速さ|容量|
|-|-|-|-|
|CPUキャッシュ(SRAM)|0.5-2.5ns|数KiB-数MiB|
|主記憶(DRAM)|50-70ns|数GiB|
|フラッシュメモリ|5-50μs|〜1TiB|
|磁気ディスク|5-20ms|数TiB|

## システムコール
ユーザプログラムからOSへの作業依頼.ユーザプログラムはOSに割り込まれる。

### 主要システムコール
* Process
    * fork() - 戻り値 != 0 なら親
    * waitpid(pid, &statloc, options)
    * execve(name, argv, environp)
    * exit(status)
* File
    * open(file, how, ...)
    * close(fd)
    * read(fd, buffer, nbytes)
    * write(fd, buffer, nbytes)
    * stat(name, &buf) - ファイルの状態を獲得
* Direcetory, file system
    * mkdir(name, mode)
    * rmdir(name)
    * link(name1, name2)
    * unlink(name)
    * mount(special, name, flag)
    * umount(special)
* other
    * chdir(dirname)
    * chmod(name, mode)
    * kill(pid, signal)
    * time(&seconds)

## 構造種類
* Monolithic System - メイン手続き・サービス手続き・ユーティリティ手続き
* 階層システム(General)
    * 5 - オペレータ
    * 4 - ユーザプログラム
    * 3 - 入出力管理
    * 2 - オペレータとプロセス間の通信
    * 1 - メモリとドラムの管理
    * 0 - プロセッサ割り当てとマルチプログラミング
* Layered System
* Virtual Machine
* Exokernels
* Client-Server Model - サーバプロセスに要求してサービスを獲得する
* Independent running kernel
* Kernel running in the user process
* microkernel

---

## プロセス
プログラム。`1つのアドレス空間に１つの制御スレッドをもつ`
プログラムカウンタ・レジスタなどの値を持つ。
実行するプログラムやコマンドを OS が管理する単位
※ ジョブは、シェルが管理するプログラムの実行単位. 複数のプロセスをまとめて１ジョブとなることもある

* 並列性 - マルチプロセッサ・マルチプロッセッシング(擬似)
* 同時性 - 複数のプロセスが同時に実行されている（ように見える）
* 割り込み - 優先度によって、割り込むか決まる

### 生成
* init
* fork
* コマンド
* 入力キューから取り出し

### 終了
* exit - 正常終了、エラー終了
* kill - 強制終了

### 階層
* プロセスの親は１つ
* 親から子をkillできない
* 子は継承した性質を変更できる

### 状態
1. 実行中
2. 実行可能
3. 待ち
4. (終了)

スケジューラが各プロセスを管理する(割り込みハンドラ・プロセス開始・終了など)

### 実現
* プロセステーブル -
* 仮想メモリ管理システム - 複数のプロセスが１つの物理メモリを効率よく使うため

---

## スレッド
実際にCPUで実行される単位
プロセス上での多重プログラミングをサポート
同時に複数の仕事をする
同一プロセスに属するスレッドは、同じコードやデータ、ヒープ、DLLなどのメモリ空間を共有
プロセス中のスレッドは同じアドレス空間にあり、並列に動作する
各スレッドは、プロセスのいくつかの情報をもつ(メモリ、グローバル変数、子プロセスなど)
スレッドがないと、例えばI/Oブロッキングが起きた時に、全ての仕事が止まってしまう。

|プロセスごと|スレッドごと|
|-|-|
|１つのアドレス空間|１つのプログラムカウンタ|
|グローバル変数|レジスタ|
|ファイル|１つのスタック|
|子プロセス|状態|
|アラーム||
|シグナル・シグナルハンドラ||
|課金情報||

* 並列性 - プロセスを並列化できる仕事の組み合わせに再構成
* 独立性 - 各仕事は他スレッドから影響を受けず動作する

### 利点
* 同時実行
* 生成と消滅処理が早い
* あるジョブで計算（CPUバウンド)と入出力(IOバウンド)が混在している時、これらをオーバラップさせ効率化する

※ 全てがCPUバウンドの仕事をマルチスレッド化しても無意味

### ユーザスレッド
ユーザ空間に実装
実行時システムがスケジューラとして動作
割り込みがないのでスレッド切り替えが効率的
OSに依存しない
スレッドのブロックがプロセスをブロック

### カーネルスレッド
カーネル空間に実装
OSがスケジューラとして動作
スレッド切り替えはカーネルが行い、遅い
プロセス管理情報にスレッド情報を追加して管理
プログラミングが容易
実行時システムが不要
消滅スレッドの再利用
ページフォルトが発生しても他スレッドを実行可能
メモリ空間の制約

### ハイブリッド
カーネルスレッド上で複数のユーザスレッドを実装

### ポップアップスレッド
分散システムで有用される
メッセージの到着をまち、到着したら新たにスレッドを生成する

### スレッドスケジューリング
ユーザスレッドでは、各時間(CPU burst)ごとに自発的にスレッドを切り替える
カーネルスレッドでは、実行後にブロックされる

---

## プロセス間通信

* クリティカルリージョン - 競合状態が起こり得る場所
* 相互排除 - プロセスで使用中の資源に他プロセスから同一の動作をできなくする
    * ビジーウェイト - 変数がある値になるまでチェックする
        * 割り込み不許可
        * ロック変数
        * 完全な交互実行
        * Petersonの解決法
        * TSL(Test and Set Lock)
    * スピンロック - ビジーウェイトを用いたロック

### セマフォ
非負の整数値をもつ
スリープからウェイクアップすべき個数をカウントする
Down - 1以上なら１減らす. 0ならスリープに入る　。
Up - １足す

* mutex - 相互排除用. 0ならアンロック状態. mutext_lock, unlock
* empty - 同期用(バッファの空きスロット)
* full - 同期用(バッファの使用スロット)

---

## スケジューリング

### CPUスケジュール
複数のプロセスが実行可能状態の時(プロセスが生成された時、プロセスが終了した時、I/O処理でブロック状態に遷移した時、ブロック状態から脱出した時)に、次に実行すべきプロセスを選択する

### アルゴリズム
* アルゴリズム分類
    * Non-preemptive - ブロックか終了するまで動く
    * preemptive - 決められた時間だけ動く
* 指標
    * 公平性
    * スループット
    * ターンアラウンド - ジョブ投入から処理が終わるまでの時間
    * CPU使用率（効率） - 稼働率を100%に保つ
    * 応答時間
    * 比例性 - 要求する時間が長ければ応答時間も長くなる
* 分類
    * 全てのシステム - 公平性、バランス
    * バッチシステム - スループット、ターンアラウンド、CPU使用率
    * 会話型システム - 応答時間、比例性
    * リアルタイムシステム　- データの紛失を防ぐ、品質を保つ

### アルゴリズム種類
* FCFS(First Come, First Served - 到着順)
    * 到着順に処理, 横取りなし
    * シンプルで実装しやすいが効率は良くない
* SF(Shortesst job first - 最短ジョブ優先)
    * 実行時間が短い物から処理、横取りなし
    * 実行時間を知っている必要がある
* STCF(Shortest Time to Completion Firft - 最小残り時間優先)
    * SFの横取り可能版
    * 実行中のジョブより短いジョブがきたら先に処理する
* RR(Round Robin)
    * 一定時間（クオンタム）ごとにジョブを切り替える
    * 横取りされたらキューの最後尾に並べなおす
    * 対話的プロセスには有用
* Priority Scheduling
    * 優先度を設定し、高いものからRound Robin
    * 優先度を途中で変更してもok
* 複数キュー方式
    * 優先度ごとに、クオンタム(2^n)を設定する
* 富くじ方式
    * 抽選
* 公平共有方式


## デッドロック
資源の取り合いが起こり、処理が止まってしまう
デッドロックが起きる条件
1. 相互排他 - 各リソースが１つのプロセスのみに与えられているか、利用可能である
2. 保持と待機条件 - 現時点でリソースの所有を認められているプロセスがさらに新しいリソースの要求ができる
3. 横取り不可能 - 先に許可されたリソースは強制的にプロセスから奪えない
4. 循環待機 - ２個以上のプロセス循環鎖があり、各鎖の次のメンバが保有するリソースを持っている

回避
1. 問題を無視する
2. 検知と復旧
3. 動的回避
4. 条件のうち１つでも消す

回復
1.　横取り - 他プロセスからの資源の剥奪
2.　ロールバック - 定期的な情報収集、保存された情報を使用、チェックポイントにもどり再開
3.　プロセス強制終了

回避方法
1. Banker's Algorithm - 要求があったら、安全に実行できるかを考え、大丈夫なら実行、無理なら延期する

防止
* 相互排他 - 単一プロセスを資源を排他的に割り当てる
* 保持と待機 -
    * 資源を持つプロセスが追加の資源を要求しない
    * 実行前に資源を要求を行う
    * 全て獲得できるまで待機
* 優先取得不可能 - 資源の先取りを禁止
* 循環待機　- プロセスに一時に一つの資源のみ割り当て
