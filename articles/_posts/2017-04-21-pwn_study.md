---
layout: post
title: Pwn Memo
date: 2017-04-21
categories: ctf
---

## メモリレイアウト

|name|exp|
|:--:|:--:|
|.text|アセンブリコード|
|.data|初期値有りデータ|
|.bss|初期値無しデータ|
|heap ↓|動的確保領域|
|shared object|共有オブジェクト(libc.so)|
|stack ↑|スタック領域|
|kernel-area|カーネルが使用|

`$gdb-peda vmmap`か、`cat /proc/$PPID/maps`で確認

`0x1000`倍数で確保される(ページ)。プロセス起動時にmmapで確保。

ユーザからは仮想メモリしか見れない。

ASLR(アドレス空間配置のランダム化.下位7bitランダム化)、PIE(位置独立実行形式.下位4bitランダム化)、NS(text領域以外の実行権限を落とす)の確認ができる。

外部ライブラリ(*.so)のアドレスを保存するテーブル(GOT)の権限を決めるのがRELRO

## ヒープ

malloc()でヒープ領域からメモリ確保、free()で解放。

利用中
```
prev_size
size
data - sizeが8の倍数になるようにパディング
```
sizeの下位３bit
1. PREV_INUSE - 直前チャンクが利用中かどうか
2. IS_MMAPED - mmapで確保されたアドレスかどうか
3. IS_NON_MAINARENA - メインのARENAから確保したかどうか

解放済み
```
prev_size
size
fd - 次のfree済みチャンクのアドレス
bk - 前のfree済みチャンクのアドレス
```

free()したときに、すぐ隣にfree済みチャンクがあれば結合

|P2|
|:--:|
|P|
|P->fd|
|P->dk|

free(P2)した時、P2とPを結合するためにPを一旦リストから外す(unlink. `P->fd->bk = P->bk, P->dk->fd = P->fd`)

### Use After free

1. new で確保(ptr)
2. delete - この時、バグでこのアドレスに読み書きができてしまうとする
3. new で確保(ptr2)。たまたまptrで確保したアドレスから確保
4. ptr2がオブジェクトなら仮想関数テーブル(vptr)を持っている
5. ptrがまだ利用可能で、ptrを書き換えるとvptrを変更できてしまう。

## Unlink Attack

ヒープBOF時に直下がfree済みチャンクの時、fd/dkメンバを上書きできる

* P->fd->bk == P
* P->bk->fd == P
の時、発動できる

### fastbins

高速化のためにデータサイズごとにリストを作る(8の倍数)

## スタック

### Stack BOF

* サイズ制限がなければ自由に上書きできる -> Return先も指定可

リターン先アドレス（例えばシェルコード）のアドレスを推測するには？

* nop-sled - shellcodeまでをnop(0x90)で埋めれば、nop-sledのどこかにたどり着けばshellcodeまでたどり着ける。
* ret2esp - jmp esp, call espなどを使いshellcodeを呼ぶ
* Stager - 短いアセンブリコードを送り込み、shellcodeを追加読み込みさせる

### スタック実行不可(NX) - stack,heap領域を実行不可にする

回避するには？？

書き込み可能な固定アドレスを作り、シェルコードを書き込み実行する。

ここでplt(外部関数アドレスを動的に求める機構)を使う。 -> ret2plt
* ret2plt - ret2pop(コード中のpopを呼び出す)を組み合わせるとret2pltを連続で呼べる
  * pedaで ropgadgetで見つかる

使いたい関数がpltにない場合 -> ret2libc

## ret2libc

libc内の関数オフセットはファイルでもメモリでも固定なので、ベースアドレスを加算されるだけ。

使いたい関数のオフセットを調べておき、あとはlibc.soの先頭アドレスに加算すれば良い。

* libc内の関数アドレス調査
  * ldd ropasaurusrex - libc path
  * objdump -d path2libc | grep "system>:"
* libc内の固定文字列調査
  * strings -tx /lib/i386-linux-gnu/libc.so.6 | grep 'bin/sh'

対象と自分の環境でアドレスが変わる場合は0x1000ごとにブルートフォース

ret2libcの対策としてASLR(アドレスのランダム化)

* ASLRの回避
  * GOTを利用。一度解決されたGOTには元の外部アドレスが書かれる。ここからlibcのベースアドレスを求め、オフセットを足して目的の関数を計算。

### ROP

.text内のコードの断片(rop gadget)を組み合わせていく。

ropgadgetの探索 -> rp++

.text内に、ropgadgetが少ない場合にlibc内のガジェットを利用もできる。

大量のBOF量が必要なので、-> stack pivot

* stack pivot
  * bss(適当なところ)にROPを読み込んで置いて、最後にleaveでbssへ飛ばして、bssをスタックとして続けていく。
  * off-by-one stack bof(1バイトしかbofしない)にも有効。


## 動的デバッグ環境

接続先の実行ファイルをgdbで見たい。

* main.sh - `gdbserver localhost:40800 ./ropasaurusrex`
* `socat tcp-listen:40801, reuseaddr,fork exec:"./main.sh"`
* Attack
  * `perl -e 'print "A"*128 ."BBBB"' | nc localhost 408001`
* vi cmd - `file ./ropasaurusrex \n target remote localhost:40800 \n c`
* `gdb ./ropasaurusrex -q -x cmd`


## 情報収集

* plt/got - `objdump -d -M intel file | grep "@plt>:" -A1`, `readelf -r`
* ropgadget - `gdb ropgadget`
* .data - `readelf -S file | fgrep .data`
* libc system offset - `$ldd file $objdump -d /lib/i386-linux-gnu/libc.so.6 | grep "system>:"`


## テクニック
ROP
* __libc_csu_init - スタックからレジスタへ値を入れられる汎用ガジェット
* alarm(x) - exa/raxにropで任意の値を入れたい
  * alarm(x) -> alarm(0)と実行するとeax/raxにxが入る
* Repeat-code - サンドボックスによりシステムコールが制限されているケース
  * libcにある\xEB\xFEを活用し１バイトずつ特定していく
* One-gadget-RCE - libc内に自動的にexecve("/bin/sh",0,0)を呼ぶアドレスがあるx64のみ
* ROP発展
  * JOP - jumpをベースにしたROP
  * COP - callをベースにしたrop
  * SROP - シグナル割り込みからの復帰を使って、レジスタを書き換えropを簡略化
  * BROP - 手元にバイナリがない状態でのROP

GOT Overwrite
* 気をつける関数 - strlen(), strcmp, memcmp, atoi, strtol, free

libcオフセット特定
* http://libcdb.com/

その他
* ret2dl_runtime_resolve
* _IO_jump_t Overwrite
* ld specific ptr Overwrite
* canary brute force
* master canary forging
* partial Overwrite
* gmesg command
