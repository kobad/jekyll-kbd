---
layout: post
title: PE File
date: 2017-04-21 12:00:12
categories: security
---

## Structure
http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf

1. _IMAGE_DOS_HEADER
2. _IMAGE_NT_HEADERS
  3. Signature
  4. IMAGE_FILE_HEADER
  5. IMAGE_OPTIONAL_HEADER
3. _IMAGE_SECTION_HEADER
4. ...
5. _IMAGE_SECTION_HEADER

## PE Header

### _IMAGE_DOS_HEADER
```
struct _IMAGE_DOS_HEADER {
0x00 WORD e_magic;    // PEファイルかどうかの判断. 5A 4D (MZ)が入る。
0x02 WORD e_cblp;
0x04 WORD e_cp;
0x06 WORD e_crlc;
0x08 WORD e_cparhdr;
0x0a WORD e_minalloc;
0x0c WORD e_maxalloc;
0x0e WORD e_ss;
0x10 WORD e_sp;
0x12 WORD e_csum;
0x14 WORD e_ip;
0x16 WORD e_cs;
0x18 WORD e_lfarlc;
0x1a WORD e_ovno;
0x1c WORD e_res[4];
0x24 WORD e_oemid;
0x26 WORD e_oeminfo;
0x28 WORD e_res2[10];
0x3c DWORD e_lfanew;  // _IMAGE_NT_HEADERSがどこにあるかを調べるための値
};
```

### _IMAGE_NT_HEADERS

```
struct _IMAGE_NT_HEADERS {
0x00 DWORD Signature;                       // 50 45 00 00 (PE\0\0)
0x04 _IMAGE_FILE_HEADER FileHeader;
0x18 _IMAGE_OPTIONAL_HEADER OptionalHeader;
};
```

#### _IMAGE_FILE_HEADER
```
struct _IMAGE_FILE_HEADER {
0x00 WORD Machine;                // どのCPUで実行できるか
0x02 WORD NumberOfSections;       // セクション数
0x04 DWORD TimeDateStamp;         // ビルドした日付
0x08 DWORD PointerToSymbolTable;  //
0x0c DWORD NumberOfSymbols;       //
0x10 WORD SizeOfOptionalHeader;   // _IMAGE_OPTIONAL_HEADERのサイズ
0x12 WORD Characteristics;        // ファイル形式を表す
};

```

#### _IMAGE_OPTIONAL_HEADER
```
struct _IMAGE_OPTIONAL_HEADER {
0x00 WORD Magic;                    // 32bit -> 0x10B, 64bit -> 0x20B
0x02 BYTE MajorLinkerVersion;       // どのバージョンのコンパイラでビルドしたか
0x03 BYTE MinorLinkerVersion;
0x04 DWORD SizeOfCode;              // コード全体のサイズ
0x08 DWORD SizeOfInitializedData;   //
0x0c DWORD SizeOfUninitializedData;
0x10 DWORD AddressOfEntryPoint;         // 実行開始アドレス
0x14 DWORD BaseOfCode;                  // コード領域の開始相対アドレス 0x1000が指定され、実際のアドレスはImageBase + BaseOfCode = 0x401000
0x18 DWORD BaseOfData;
0x1c DWORD ImageBase;                   // 実行時に仮想メモリにロードされるアドレス. 0x400000
0x20 DWORD SectionAlignment;            // セクションの区切り単位. 基本0x1000
0x24 DWORD FileAlignment;
0x28 WORD MajorOperatingSystemVersion;
0x2a WORD MinorOperatingSystemVersion;
0x2c WORD MajorImageVersion;
0x2e WORD MinorImageVersion;
0x30 WORD MajorSubsystemVersion;
0x32 WORD MinorSubsystemVersion;
0x34 DWORD Win32VersionValue;
0x38 DWORD SizeOfImage;                 // 実行ファイルがメモリにロードされた時の全体サイズ
0x3c DWORD SizeOfHeaders;               // PEヘッダのサイズ
0x40 DWORD CheckSum;
0x44 WORD Subsystem;                    // プログラムがGUIかコンソール用か
0x46 WORD DllCharacteristics;
0x48 DWORD SizeOfStackReserve;
0x4c DWORD SizeOfStackCommit;
0x50 DWORD SizeOfHeapReserve;
0x54 DWORD SizeOfHeapCommit;
0x58 DWORD LoaderFlags;
0x5c DWORD NumberOfRvaAndSizes;
0x60 _IMAGE_DATA_DIRECTORY DataDirectory[16]; // それぞれ役割がある。
};
```

#### _IMAGE_DATA_DIRECTORY
```
struct _IMAGE_DATA_DIRECTORY {
  0x00 DWORD VirtualAddress;
  0x04 DWORD Size;
}

```
* Image Data Directory - オプションヘッダの最後にある
   * Export Table  -  他の実行可能ファイルからアクセスできる関数についての情報
   * Import Table  - 他の実行可能ファイルからアクセスして呼び出す関数についての情報
   * IAT                 - 他の実行可能ファイルからアクセスして呼び出す関数のアドレス

### _IMAGE_SECTION_HEADER

プログラムコード、データ、リソースなどを格納する各セクションの構造を示す情報が並ぶ

```
typedef struct _IMAGE_SECTION_HEADER {
0x00 BYTE Name[IMAGE_SIZEOF_SHORT_NAME];  // UTF-8の文字コードでのセクション名を格納する(8BYTE)
      union {
0x08    DWORD PhysicalAddress;
0x08    DWORD VirtualSize;                // UTF-8の文字コードでのセクション名を格納する
      } Misc;
0x0c DWORD VirtualAddress;                // メモリに読み込まれた時のセクション先頭のアドレス
0x10 DWORD SizeOfRawData;                 // 実行可能ファイル中でのセクションサイズ
0x14 DWORD PointerToRawData;              // 実行可能ファイル中でのセクション先頭のオフセット
0x18 DWORD PointerToRelocations;
0x1c DWORD PointerToLinenumbers;
0x20 WORD NumberOfRelocations;
0x22 WORD NumberOfLinenumbers;
0x24 DWORD Characteristics;               // セクションの属性を示すフラグで各属性を意味する値の論理和が格納
};
```

* セクションの属性フラグ
  * IMAGE_SCN_CNT_CODE(0x00000020) -  実行可能なコード
  * IMAGE_SCN_CNT_INITIALIZED(0x00000040) - 初期化したデータ
  * IMAGE_SCN_CNT_UNINITIALIZED_DATA(0x00000080) - 初期化されてないデータ
  * IMAGE_SCN_MEM_EXECUTE(0x20000000) - コードとして実行できる
  * IMAGE_SCN_MEM_READ(0x40000000) - 読み込みできる
  * IMAGE_SCN_MEM_WRITE(0x80000000) - 書き込みできる
* 代表セクション
  * .text -> プログラムコード
  * .edata -> 関数などのエクスポートデータ
  * .idata -> 関数などのインポートデータ
  * .data -> 初期化されたデータ
  * .bss -> 初期化されてないデータ
  * .rsrc -> リソース



----

## .NET

https://codingwithspike.wordpress.com/2012/07/26/building-a-net-disassembler-part-2-reading-virtual-directories-and-sections/

### clr_header
```
typedef struct IMAGE_COR20_HEADER
{
    DWORD                   cb;              
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;
    IMAGE_DATA_DIRECTORY    MetaData;        
    DWORD                   Flags;           
    union {
        DWORD               EntryPointToken;
        DWORD               EntryPointRVA;
    };
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;
}
```

### METADATA_HEADER
```
struct MetadataStreamHeader {
0x00 DWORD Signature
0x04 WORD MajorVersion
0x06 WORD MinorVersion
0x08 DWORD Reserved1
0x0c DWORD VersionStringLength
0x10 STRING VersionString
0xXX WORD Flags
0xXX WORD NumberOfStreams
}
```

### Resource file

```
struct {
  DWORD Signature // 0xBEEFCACE
  DWORD NumberOfReaders
  DWORD sizeOfReaderTypes
  strings
  DWORD ResourceFileVersion
  DWORD NumberOfActualResources
  DWORD NumberOfResourceTypes
}
```

----


## IAT (Import Address Table)

プログラムで使用するAPI関数のプログラムコード開始位置のアドレスを格納したテーブル。
プロセスが作成される時に、各DLLファイルが読み込まれたアドレスをベースにしてこのメモリ上の実行可能ファイル内にあるIATを実際の関数開始アドレスで書き換える。
プログラムはIATを参照すればAPI関数を呼び出せるようになる。


## DLL (Dynamic Link Library)

プログラムに動的にリンクするライブラリ

単体では動かない

実行ファイル内にあらかじめどのDLLがどの関数を使うかの情報を格納しておくことがおおい。実行途中に指定することも可能。LoadLibrary関数を使う

OSからアプリケーションへAPI関数を提供するインターフェイスとも言える

## カーネルドライバ - カーネルモードで動作するドライバ

ドライバ - OSと同じく、カーネルモードで動作するプログラムとして実行される。

OS深部にアクセスできるため、OSのみが保持してる情報を取得できる。OSの深層部にあるデータを変更してプロセスを隠蔽できる。

## プロセス実行の仕組みとスレッド

プロセス - 実行処理単位

1. 初期化処理 - スタックやメモリの準備やIATの書き換えがされて、メモリ領域の確保と実行可能ファイルのリンクをする
2. 一つずつニーモニックを実行していく

Windows上でのプロセス実行処理はタイムスライス(ごく短い時間でプロセスを切り替えて実行し、同時に実行しているように見せる)で動いている(マルチタスク)。切り替え時にはレジスタ内のデータを一時退避して、次には復元して続きを行う。


スレッド - プロセスをさらに小さい実行単位に分けた単位

* スレッドの追加 - 新たなスレッドとして次に実行するアドレスを指定して追加。各スレッドはプロセスメモリを共有する。
  * CreateThread - 自分のプロセス内に追加
  * CreateRemoteThread - 他のプロセス内に追加

プロセスメモリ上には、詳細な情報が記された構造体がある(PEB - Process Environment Block)。
各スレッドにも、詳細な情報が記された構造体がある(TEB - Thread Environment Block)。

プロセスメモリ(仮想アドレス空間)は各プロセスごとに独立していて、基本的に互いに干渉できない。ページング方式(プロセスメモリをページという小さな単位に分けて、リアルタイムで使われるページだけメモリに読み込み、他はHDDなどに保存しておく)が使われている。
