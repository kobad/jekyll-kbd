---
layout: post
title: PE File
date: 2017-04-21 12:00:12
categories: security
---
# PE(Portable Executable) File

## Structure

構造例

ヘッダには多くの情報が格納されているがその中でも重要なものを説明

## PE Header

詳しくはMicroSoftの資料参考

1. MZ スタブ
  * MS-DOS上で実行可能なプログラム形式
  * PEファイルであることを示すシグネチャの先頭オフセット(0x3C)が格納。これ以降のDWord値がPEファイルのシグネチャ
  * シグネチャは 'PE(0x50 0x45)'
2. COFF ファイルヘッダ
  * 構造

```
  typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics
  } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

  * 実行環境とかを表す(Machine = 0x14C -> Intel386以降)
3. オプションヘッダ
  * プログラムが実行される上での基本的な情報を記す
  * `SizeOfCode` -> プラグラムコードのあるセクションのサイズ
  * `AddressOfEntryPoint` -> 最初に実行されるプログラムコードのイメージ相対アドレス(RVA)
  * `BaseOfCode` -> プログラムコードを格納するセクションの先頭のイメージ相対アドレス
  * `ImageBase` -> 実行ファイルがメモリに書き込まれた時の正しい先頭アドレスで、EXEなら0x400000, DLLなら0x10000000
  *  など
  * Image Data Directory - オプションヘッダの最後にある
     * Export Table  -  他の実行可能ファイルからアクセスできる関数についての情報
     * Import Table  - 他の実行可能ファイルからアクセスして呼び出す関数についての情報
     * IAT                 - 他の実行可能ファイルからアクセスして呼び出す関数のアドレス
4. セクションテーブル
  * プログラムコード、データ、リソースなどを格納する各セクションの構造を示す情報が並ぶ
  * ヘッダ
    * Name - UTF-8の文字コードでのセクション名を格納する(8byte)
    * VirtualSize - メモリに読み込まれた時のセクションサイズ
    * VirtualAddress - メモリに読み込まれた時のセクション先頭のアドレス
    * SizeOfRawData - 実行可能ファイル中でのセクションサイズ
    * PointerToRawData - 実行可能ファイル中でのセクション先頭のオフセット
    * Characteristics - セクションの属性を示すフラグで各属性を意味する値の論理和が格納
  * セクションの属性フラグ
    * IMAGE_SCN_CNT_CODE(0x00000020) -  実行可能なコード
    * IMAGE_SCN_CNT_INITIALIZED(0x00000040) - 初期化したデータ
    * IMAGE_SCN_CNT_UNINITIALIZED_DATA(0x00000080) - 初期化されてないデータ
    * IMAGE_SCN_MEM_EXECUTE(0x20000000) - コードとして実行できる
    * IMAGE_SCN_MEM_READ(0x40000000) - 読み込みできる
    * IMAGE_SCN_MEM_WRITE(0x80000000) - 書き込みできる
  * 代表セクション
    * .text -> プログラムコード
    * .edata -> 関数などのエクスポートデータ
    * .idata -> 関数などのインポートデータ
    * .data -> 初期化されたデータ
    * .bss -> 初期化されてないデータ
    * .rsrc -> リソース

## IAT (Import Address Table)

プログラムで使用するAPI関数のプログラムコード開始位置のアドレスを格納したテーブル。
プロセスが作成される時に、各DLLファイルが読み込まれたアドレスをベースにしてこのメモリ上の実行可能ファイル内にあるIATを実際の関数開始アドレスで書き換える。
プログラムはIATを参照すればAPI関数を呼び出せるようになる。


## DLL (Dynamic Link Library)

プログラムに動的にリンクするライブラリ

単体では動かない

実行ファイル内にあらかじめどのDLLがどの関数を使うかの情報を格納しておくことがおおい。実行途中に指定することも可能。LoadLibrary関数を使う

OSからアプリケーションへAPI関数を提供するインターフェイスとも言える

## カーネルドライバ - カーネルモードで動作するドライバ

ドライバ - OSと同じく、カーネルモードで動作するプログラムとして実行される。

OS深部にアクセスできるため、OSのみが保持してる情報を取得できる。OSの深層部にあるデータを変更してプロセスを隠蔽できる。

## プロセス実行の仕組みとスレッド

プロセス - 実行処理単位

1. 初期化処理 - スタックやメモリの準備やIATの書き換えがされて、メモリ領域の確保と実行可能ファイルのリンクをする
2. 一つずつニーモニックを実行していく

Windows上でのプロセス実行処理はタイムスライス(ごく短い時間でプロセスを切り替えて実行し、同時に実行しているように見せる)で動いている(マルチタスク)。切り替え時にはレジスタ内のデータを一時退避して、次には復元して続きを行う。


スレッド - プロセスをさらに小さい実行単位に分けた単位

* スレッドの追加 - 新たなスレッドとして次に実行するアドレスを指定して追加。各スレッドはプロセスメモリを共有する。
  * CreateThread - 自分のプロセス内に追加
  * CreateRemoteThread - 他のプロセス内に追加

プロセスメモリ上には、詳細な情報が記された構造体がある(PEB - Process Environment Block)。
各スレッドにも、詳細な情報が記された構造体がある(TEB - Thread Environment Block)。

プロセスメモリ(仮想アドレス空間)は各プロセスごとに独立していて、基本的に互いに干渉できない。ページング方式(プロセスメモリをページという小さな単位に分けて、リアルタイムで使われるページだけメモリに読み込み、他はHDDなどに保存しておく)が使われている。
